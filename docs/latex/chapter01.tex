% chapter01.tex

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                           %
 %    YABBY documentation                                                    %
 %    Copyright (C) 2007 Vladimir Likic                                      %
 %                                                                           %
 %    The files in this directory provided under the Creative Commons        %
 %    Attribution-NonCommercial-NoDerivs 2.1 Australia license               %
 %    http://creativecommons.org/licenses/by-nc-nd/2.1/au/                   %
 %    See the file license.txt                                               %
 %                                                                           %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\setcounter{section}{0}

\chapter{Basics}

\section{Introduction}

- Introduction
- Motivation
- Features
- License

Yabby is released as open source, under the GNU Public License
version 2.

\section{Installation}

\subsection{Checking Perl}

\index{installation}
\index{Perl}
\index{system requirements}

Yabby has been developed with Perl version 5.X, a freely available
general purpose scripting language. Perl stands for "Practical
Extraction and Report Language" and is particularly well suited for
the manipulation of data stored in plain text files. This seems
all too often to be required in bioinformatics applications.

Before attempting the installation, it is highly recommended to
check if the Perl interpreter is present your computer system.
For example, on a Linux system,

\begin{verbatim}
$ perl -v

This is perl, v5.8.5 built for i386-linux-thread-multi

Copyright 1987-2004, Larry Wall

Perl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.

Complete documentation for Perl, including FAQ lists, should be found on
this system using `man perl' or `perldoc perl'.  If you have access to the
Internet, point your browser at http://www.perl.com/, the Perl Home Page.
\end{verbatim}

Perl 5 and later is required for Yabby.  The next step is to find where
exactly is the Perl interpreter located, as this information will be
required for Yabby installation:

\begin{verbatim}
$ which perl
/usr/local/bin/perl
\end{verbatim}

\subsection{Downloading Yabby}

Yabby source code can be browsed from the Google Code servers, at
the URL: http://code.google.com/p/yabby/. Under the
section "Source" one can find the instructions for downloading the
source code. The same page provides the link under "This project's
Subversion repository can be viewed in your web browser" which allows
one to browse the source code on the server without actually
downloading it.

Google servers maintain the source code by the program called 'subversion'
(an open-source version control system).  To download the source code
one needs to use the subversion client program called 'svn'.  The 'svn'
client exists for all mainstream operating systems\footnote{For example,
on Linux CentOS 4 the RPM package 'subversion-1.3.2-1.rhel4.i386.rpm'
provides the subversion client 'svn'.}, for more information see
http://subversion.tigris.org/.  The book about subversion is freely
available on-line at http://svnbook.red-bean.com/. Subversion has
extensive functionality however only the very basic functionality
is needed to download Yabby.  Assuming that the computer is connected
to the internet, the following command will download the latest Yabby 
source code in the current directory:

\begin{verbatim}
$ svn checkout http://yabby.googlecode.com/svn/trunk/ yabby
A    yabby/yabby.pl
A    yabby/LICENSE
A    yabby/lib
A    yabby/lib/blast.pl
A    yabby/lib/hmm_score2seq.pl
A    yabby/lib/seq_strip.pl
A    yabby/lib/seq_comment.pl
A    yabby/lib/hmm_score.pl
A    yabby/lib/blastg.pl
A    yabby/lib/motif_cmp.pl
A    yabby/lib/seq_unique.pl
A    yabby/lib/yabby_seq.pm
....further output deleted....
\end{verbatim}

\subsection{Yabby installation}

Yabby installation requires that the file 'yabby/lib/yabby.pl' is
modified to to set the path to the Perl language interpreter,
and to Yabby libraries.

If Yabby code was downloaded in the directory /home/jake/ (and
therefore the script 'yabby.pl' is in /home/jake/yabby/), to set
the path to Yabby libraries the following two lines need to be
set: 

\begin{verbatim}
use lib "/home/jake/yabby/lib";
$LIB_DIR = "/home/jake/yabby/lib";
\end{verbatim}

The path to the Perl interpreter is set in the first line of the
file 'yabby.pl':

\begin{verbatim}
#!/usr/bin/perl
\end{verbatim}

The script yabby.pl needs to have executable permissions:

\begin{verbatim}
$ chmod +x yabby.pl
\end{verbatim}

If this is all set, running the script 'yabby.pl' will start Yabby:

\begin{verbatim}
$ yabby.pl

 - YABBY version 0.1 - 
   Copyright (c) 2004-7 Vladimir Likic
 [ 35 command(s) ready ]

yabby>
\end{verbatim}

It is often useful to create a symbolic link in a directory which
is included the PATH variable, such as /usr/local/bin or ~/bin:

\begin{verbatim}
ln -s /home/jake/yabby/yabby.pl /home/jake/bin/yabby
\end{verbatim}

This would allow Yabby to be run from any directory, simply by
typing 'yabby'.

\section{Running Yabby}

\subsection{An interactive session}

Yabby can be run interactively or from the command script. To
start an Yabby interactive session one needs to start the Yabby
interface from the Unix shell. Here is the simplest Yabby session:

\begin{verbatim}
$ yabby

 - YABBY version 0.1 - 
   Copyright (c) 2004-7 Vladimir Likic
 [ 35 command(s) ready ]

yabby> quit

 bye-bye
\end{verbatim}

\subsection{Yabby command scripts}

In order to run Yabby from the command script, the command file
needs to be prepared first. Such a file lists Yabby commands
one per line, with optional blank lines (lines which start with
the \% character are ignored). For example, the following input
file, named test.yab,

\begin{verbatim}
% test.yab -- test input script

seq_load cad3.seq cad3
seq_info -l cad3
\end{verbatim}

could be run with the Unix shell input redirection:

\begin{verbatim}
$ yabby < test.yab

 - YABBY version 0.1 - 
   Copyright (c) 2004-7 Vladimir Likic
 [ 35 command(s) ready ]

yabby> % test.yab -- test input script
yabby> yabby> 
 Reading the file 'cad3.seq' ..
 3 sequence(s) found.

yabby> 
 'cad3' contains 3 sequence(s)
  1 -> Q53650_STAAU, 192 residues
  2 -> Q97PJ0_STRPN, 193 residues
  3 -> P95773_STALU, 192 residues

yabby> yabby> 
 bye-bye
\end{verbatim}

When run from the command script the actual commands are not
echoed back, only the command's screen output as well as the
comments.

\subsection{Executing Unix commands}

\index{unix commands}

Any command which is not recognized by Yabby is assumed to be
an Unix command, and Yabby will attempt to execute it. Consider
the following example:

\begin{verbatim}
yabby> ls
1BT0.pdb  cox1.seq     LmjFmockup.pep  needle.out
cad3.seq  dna.seq      m2.blocks       README
cad.seq   hmmpfam.out  meme.out        test.yab
yabby> l

 [ UNIX command 'l' failed ]
\end{verbatim}

Because there is no Yabby command {\tt ls}, it was assumed to
be a system command and executed.  The output was printed on
the screen, listing the files and directories in the directory
where Yabby was started.

Subsequently, the command {\tt l} was given but failed because
there is no such Yabby or Unix command. If {\tt l} was an alias
to something (say {\tt ls -CF}) the command would fail regardless,
because Yabby does not know about shell aliases.

There are no inherent limitations to which Unix commands can be
executed within Yabby. It is possible to run a text editor, such
as "vi" (and then simply resume the Yabby session after exiting
the editor), or even start programs with GUI such as "gnuplot",
or a Unix terminal window.

A subtle but important point is that in Yabby Unix commands are
not executed through the Unix shell.  The consequence of this
is that the (sometimes important) functions provided the the
Unix shell, such as file globing, are not available. For example:

\begin{verbatim}
yabby> ls *
ls: *: No such file or directory

 [ UNIX command 'ls *' failed ]
\end{verbatim}

A handy trick which allows one to go about Unix business is
to temporarily suspend Yabby. This is actually a feature provided
by some unix shells (in combination with the system's terminal driver),
and has little to do with Yabby. In short, typing Ctrl-Z within
Yabby will suspend the current Yabby session, and return user
to the Unix shell. Issuing the command "fg" to the same shell
will return the suspended Yabby session:

\begin{verbatim}
yabby> [Cntrl-Z]
[1]+  Stopped                 yabby
$ ls -CF
1BT0.pdb  cox1.seq     LmjFmockup.pep  needle.out
cad3.seq  dna.seq      m2.blocks       README
cad.seq   hmmpfam.out  meme.out        test.yab
$ fg

yabby>
\end{verbatim}

Ctrl-Z was typed on the first line, which was not echoed back. Note
that the second command prompt (starting with the {\tt \$} character)
is the Unix shell prompt, and typing "fg" had returned user to
the suspended Yabby session.

\section{Understanding how Yabby works}

To understand how Yabby works it is important to understand the
relationship between three directories: the working directory
(where the Yabby session has been started), the Yabby library (this
is the lib/ subdirectory in the the Yabby installation directory),
and the workspace directory.

The workspace directory is created automatically when the Yabby
session is initialized. By default, the workspace directory is
called .yabby, and it is created in the working directory. The
workspace directory contains all the yabby objects created within
the session. Upon graceful exit from the Yabby shell, the workspace
directory is destroyed together with its content.

\subsection{The exchange of data between command scripts}

Consider what happens when the sequences were read from the file
'tom20.fas' to create a sequence object in the workspace:

\begin{verbatim}
1  $ yabby
2 
3   - YABBY version 0.1 -
4     Copyright (c) 2004-7 Vladimir Likic
5   [ 35 command(s) ready ]
6 
7  yabby> seq_load tom20.fas tom20
8  
9   Reading the file 'tom20.fas' ..
10  3 sequence(s) found.
11 
12 yabby> what
13 
14     object(s)      type
15   ------------------------------
16     tom20          seq   
17 
18 yabby> print tom20.seq
19
20 >A.thaliana2 [ A.thaliana2 ]
21 MEFSTADFERFIMFEHARKNSEAQYKNDPLDSENLLKWGGALLELSQFQPIPEAKLMLND
22 AISKLEEALTINPGKHQALWCIANAYTAHAFYVHDPEEAKEHFDKATEYFQRAENEDPGN
23 DTYRKSLDSSLKAPELHMQFMNQGMGQQILGGGGGGGGGGMASSNVSQSSKKKKRNTEFT
24 YDVCGWIILACGIVAWVGMAKSLGPPPPAR
25 >O.sativa [ O.sativa ]
26 MDMGAMSDPERMFFFDLACQNAKVTYEQNPHDADNLARWGGALLELSQMRNGPESLKCLE
27 DAESKLEEALKIDPMKADALWCLGNAQTSHGFFTSDTVKANEFFEKATQCFQKAVDVEPA
28 NDLYRKSLDLSSKAPELHMEIHRQMASQASQAASSTSNTRQSRKKKKDSDFWYDVFGWVV
29 LGVGMVVWVGLAKSNAPPQAPR
30 >L.esculentum [ L.esculentum ]
31 MDMQSDFDRLLFFEHARKTAETTYATDPLDAENLTRWAGALLELSQFQSVSESKKMISDA
32 ISKLEEALEVNPQKHDAIWCLGNAYTSHGFLNPDEDEAKIFFDKAAQCFQQAVDADPENE
33 LYQKSFEVSSKTSELHAQIHKQGPLQQAMGPGPSTTTSSTKGAKKKSSDLKYDVFGWVIL
34 AVGLVAWIGFAKSNMPXPAHPLPR
\end{verbatim}

In line 1 the Yabby was started from the Unix shell command line.
During the initalization process the workspace directory .yabby
was silently created. The command shown on line 7:

\begin{verbatim}
seq_load tom20.fas tom20
\end{verbatim}

will read the sequence from the file 'tom20.fas', and save the sequences
under the name 'tom20'. The command 'what' shown on the line 12 allows
one to inspect the content of the workspace. It shows that the workspace
contains one object, named 'tom20', and this object is of the type 'seq'
(it is a sequence object).  The command 'print' on the line 18 has
printed the object 'tom20' on the terminal screen.

The command 'seq\_load' has executed the script 'seq\_load.pl'
located in the Yabby library. This command reads the FASTA sequence
file and converts it into an Yabby object of the type 'seq'. The
command 'print' has executed the script 'print.pl' from the Yabby
library. The scripts 'seq\_load.pl' and 'print.pl' are completely
independent. How was the script 'print.pl' aware of the data object
'tom20.seq'?  How was the data transferred between the script
'seq\_load.pl' to the script 'print.pl' for printing?

This was achieved by the use of the workspace directory. When Yabby
was started (line 1) the workspace directory .yabby/ was silently
created in the current working directory. The newly created object
'tom20' (the result of the command 'seq\_load') was stored in the
file 'tom20.seq' in the workspace directory. On the line 18, the
command 'print' was requested to print the object 'tom20' of the
type 'seq'. The command 'print' first attempted to find the object
'tom20.seq' in the workspace. This was successful, and the object
was loaded from the workspace directory, and then printed on the
terminal screen.

Consider printing a non-existent sequence object:

\begin{verbatim}
yabby> print tom99.seq

 _print_seq:: missing requirement: 'tom99.seq'

 print:: ERROR: system script '_print_seq' failed
 [ error occurred in the subroutine call() ]
 [ command 'print' failed ]
\end{verbatim}

The message above shows that 'tom99.seq' ('tom99' object of the 
type 'seq') is not in the workspace. Furthermore, printing of the
sequence objects is handled by the system script '\_print\_seq.pl',
which is normally invoked by the command script 'print.pl'. Hence
the error message comes from '\_print\_seq'.

Consider printing of an object of a non-exiting type:

\begin{verbatim}
yabby> print tom20.ttt

 print:: ERROR: printing the property 'ttt' not yet implemented
 [ command 'print' failed ]
\end{verbatim}

In this case the error message originated from the command script
'print.pl'. This command script needs to decide which system script
to call for printing. It first determines if the printing of the
requested object type has been implemented, and bombs out if not.

The relationship between the working directory, workspace, and Yabby
library is shown in Figure \ref{fig:session}.

\begin{figure}
\centering
\includegraphics[height=6.0cm]{pics/yabby-session.eps}
\caption{The relationship between the working directory, Yabby
library, and the workspace directory. In this example the Yabby
session was started in the user's home directory (/home/jake).
During the initialization, Yabby has created the workspace directory
(/home/jake/.yabby). The execution of the command seq\_load from
the Yabby shell has executed the script seq\_load.pl from the
library, and has created the tom20.seq object. This object is
stored in the file tom20.seq, created in the workspace directory.}
\label{fig:session}
\end{figure}

\subsection{The workspace}

The workspace is the area where persistent objects are held,
normally an area of the computer memory. In Yabby, the workspace
is an area of the local persistent storage (hard disk), and more
specifically, the workspace directory (or folder). This directory
is automatically created when Yabby is started, and is silently
destroyed upon a graceful exit from Yabby. The consequence of
this is that one can directly inspect what is in Yabby's workspace. 
If the Yabby session has been started in /home/jake, and the
following command is executed:

\begin{verbatim}
yabby> seq_load tom20.fas tom20

 Reading the file 'tom20.fas' ..
 3 sequence(s) found.
\end{verbatim}

This has created the object 'tom20.seq'.  One can inspect this object
directly by using system tools:

\begin{verbatim}
$ cd /home/jake/.yabby
$ ls
tom20.seq
$ cat tom20.seq
<?xml version="1.0"?><seqroot><seqentry><seqid>A.thaliana2</
seqid><comment>A.thaliana2</comment><sequence>MEFSTADFERFIMF
EHARKNSEAQYKNDPLDSENLLKWGGALLELSQFQPIPEAKLMLNDAISKLEEALTINPG
KHQALWCIANAYTAHAFYVHDPEEAKEHFDKATEYFQRAENEDPGNDTYRKSLDSSLKAP
ELHMQFMNQGMGQQILGGGGGGGGGGMASSNVSQSSKKKKRNTEFTYDVCGWIILACGIV
AWVGMAKSLGPPPPAR</sequence></seqentry><seqentry><seqid>O.sat
iva</seqid><comment>O.sativa</comment><sequence>MDMGAMSDPERM
FFFDLACQNAKVTYEQNPHDADNLARWGGALLELSQMRNGPESLKCLEDAESKLEEALKI
DPMKADALWCLGNAQTSHGFFTSDTVKANEFFEKATQCFQKAVDVEPANDLYRKSLDLSS
KAPELHMEIHRQMASQASQAASSTSNTRQSRKKKKDSDFWYDVFGWVVLGVGMVVWVGLA
KSNAPPQAPR</sequence></seqentry><seqentry><seqid>L.esculentu
m</seqid><comment>L.esculentum</comment><sequence>MDMQSDFDRL
LFFEHARKTAETTYATDPLDAENLTRWAGALLELSQFQSVSESKKMISDAISKLEEALEV
NPQKHDAIWCLGNAYTSHGFLNPDEDEAKIFFDKAAQCFQQAVDADPENELYQKSFEVSS
KTSELHAQIHKQGPLQQAMGPGPSTTTSSTKGAKKKSSDLKYDVFGWVILAVGLVAWIGF
AKSNMPXPAHPLPR</sequence></seqentry></seqroot>
\end{verbatim}

The object 'tom20.seq' is a plain text XML document which captures
the data about sequences.

The ability to access the workspace allows one to inspect the
existing objects while they reside in Yabby's "memory", which
often comes handy. For example, this may facilitate understanding
of object's internal representation, and often greatly facilitates
implementation and debugging of data models that need to be
developed to capture new data types. 

\subsection{The data formats}

Currently Yabby implements two different data formats: two-dimensional
list (table) and XML document. In many bioinformatics applications data
can be effectively represented by two dimensional tables. Examples
include the list of atoms in a molecule, the list of atom coordinates,
the list of sequence IDs and their rankings, etc. For such data, two
dimensional tables are ideal representation. Ocassionally, the objects
which have more complex internal structure need to be handled. For
example, a list of protein sequences where each sequence may need to
be characterized with several attributes: sequence ID, organism name, 
the sequence string consisting of amino acid residues and so on.

As an example for a two-dimensional list data format, consider the
property 'mol' (molecule).

\begin{verbatim}
yabby> mol_load 1BT0.pdb rub

 661 atoms found in the molecule 'rub'

yabby> what

    object(s)      type
  ------------------------------
    rub            mol           
\end{verbatim}

The command 'mol\_load' has created the object 'rub.mol'. This object
is stored in the workspace as the file 'rub.mol':

\begin{verbatim}
$ cd .yabby
/home/jack/data/.yabby
$ ls
rub.mol
$ head rub.mol
1 MET N 
1 MET CA 
1 MET C 
1 MET O 
1 MET CB 
1 MET CG 
1 MET SD 
1 MET CE 
2 LEU N 
2 LEU CA 
\end{verbatim}

This is an example where the two-dimensional list fits perfectly
the data type: a molecule is a list of atoms, and each atom is
characterized by residue number, residue name, and atom name.
This information can be naturally arranged into a two-dimensional
table, with one atom per table row. 

On the other hand, the protein or DNA sequence is not naturally
amenable to the two-dimensional list representation. A sequence
may be characterized by several attributes (sequence ID, organism
name, database specific IDs, and so on) in addition to the sequence
itself, which may contain a few to many thousands of letters. The
matter is further complicated if the data model needs to handle
transparently one or more sequences. Yabby uses XML to represent
such data which requires more capable representations.

Consider the content of the file 'tom20.seq' which contains
the information about three tom20 sequences given previously.
If arranged in a more readable format, this sequence object
looks as given below:

\begin{verbatim}
<?xml version="1.0"?>
<seqroot>
  <seqentry>
    <seqid>A.thaliana2</seqid>
    <comment>A.thaliana2</comment>
    <sequence>MEFSTADFERFIMFEHARKNSEAQYKNDPLDSENLLKWGGALLELSQF
      QPIPEAKLMLNDAISKLEEALTINPGKHQALWCIANAYTAHAFYVHDPEEAKEHFD
      KATEYFQRAENEDPGNDTYRKSLDSSLKAPELHMQFMNQGMGQQILGGGGGGGGGG
      MASSNVSQSSKKKKRNTEFTYDVCGWIILACGIVAWVGMAKSLGPPPPAR
    </sequence>
  </seqentry>
  <seqentry>
    <seqid>O.sativa</seqid>
    <comment>O.sativa</comment>
    <sequence>MDMGAMSDPERMFFFDLACQNAKVTYEQNPHDADNLARWGGALLELSQM
      RNGPESLKCLEDAESKLEEALKIDPMKADALWCLGNAQTSHGFFTSDTVKANEFFEK
      ATQCFQKAVDVEPANDLYRKSLDLSSKAPELHMEIHRQMASQASQAASSTSNTRQSR
      KKKKDSDFWYDVFGWVVLGVGMVVWVGLAKSNAPPQAPR</sequence>
  </seqentry>
  <seqentry>
  <seqid>L.esculentum</seqid>
    <comment>L.esculentum</comment>
    <sequence>MDMQSDFDRLLFFEHARKTAETTYATDPLDAENLTRWAGALLELSQFQS
    VSESKKMISDAISKLEEALEVNPQKHDAIWCLGNAYTSHGFLNPDEDEAKIFFDKAAQC
    FQQAVDADPENELYQKSFEVSSKTSELHAQIHKQGPLQQAMGPGPSTTTSSTKGAKKKS
    SDLKYDVFGWVILAVGLVAWIGFAKSNMPXPAHPLPR</sequence>
  </seqentry>
</seqroot>
\end{verbatim}

It is apparent that each sequence is enclosed by the XML tags
$<$seqentry$>$ and $<$/seqentry$>$. Furthermore, the individual
attributes for each sequence are enclosed in tags such as
$<$seqid$>$ and $<$/seqid$>$, $<$comment$>$ and $<$/comment$>$
and so on. This allows a great flexibility in the representation
of data with complex internal structure. This flexibility comes
at a price, as it requires more effort to design and then implement
an XML based format compared to a two-dimensional list. 

\section{Extending Yabby}

The design goal of Yabby was to allow easy modification of existing
functionality and writing of new commands. As a result, extending
Yabby's functionality is very easy. The one-to-one correspondence
between Yabby commands and Yabby command scripts makes it very clear
from where the particular funcionality comes from. It also encapsulates
a functionality within a particular script file, and small size of
individual script files makes it easy to understand, modify, and
maintain them.  The other important feature is the decoupling between
the program scripts. For example, the command 'print' prints the
sequence object created by the command 'seq\_load'. This is possible
because 'seq\_load' saves the sequence object so that 'print' can
find it, and all happnes via the intermediate file stored in the
workspace directory. The complete decoupling between command scripts
ensures that it is very hard to break existing commands when adding
new commands or functionality!

Any functional Perl script placed in the Yabby library directory
will become available for execution as Yabby command.  Consider
the file 'hello.pl' with the following content:

\begin{verbatim}
print "Hello World!\n";
\end{verbatim}

If placed in the the Yabby library directory, it becomes immediately
available as the command 'hello':

\begin{verbatim}
$ yabby

 - YABBY version 0.1 - 
   Copyright (c) 2004-7 Vladimir Likic
 [ 36 command(s) ready ]

yabby> hello

Hello World!

yabby>
\end{verbatim}

If previously running, Yabby needs to be restarted before the command
'hello' becomes available.

\subsection{Creating a new Yabby command: seq\_letter}

Although a simple perl script would work if just dropped in the Yabby
library, to create a Yabby command would require some additional effort.
Consider creating a very simple command which operates on the sequence
object, and prints the first letter of the first sequence stored in
the sequence object. The command will be named 'seq\_letter'.

We start by creating the file 'seq\_letter.pl' in the Yabby library:

\begin{verbatim}
# seq_letter.pl

use yabby_sys;
use yabby_seq;

use Getopt::Std;
\end{verbatim}

All Yabby commands rely on the module 'yabby\_sys'. The module 'yabby\_seq'
contains functions for the manipulation of sequences. The Perl module
'Getopt::Std' is required to enable processing of single-character
command switches.

The next step is to create the usage string:

\begin{verbatim}
$USAGE = "
 Prints the first letter from the first sequence of a sequence
 object. 

 Usage:
        seq_letter OBJ_NAME

 where OBJ_NAME is the name of an existing sequence object.

 Notes:

 1. This command is merely an example to demonstrate how new
 Yabby commands can be developed.
";
\end{verbatim}

The usage string will be printed when 'help seq\_letter' or
'seq\_letter help' is issued.

We add the initialization commands:

\begin{verbatim}
# options
# initialization
@argl = sys_init( @ARGV );
check_call( @argl, [ 1 ] );
$obj_name = $argl[0];
\end{verbatim}

In the case of this command there are no options. The function
'sys\_init' is used to process arguments to all Yabby commands
in a standard way. The function 'check\_call' is used to check
the number of arguments.  In this case, exactly one argument
must be given, the name of an existing sequence object.  Finally,
in the last line the name of sequence object is associated to
the variable 'obj\_name'. In the next step the sequence object
is loaded in the memory:
 
\begin{verbatim}
requirements( $obj_name, $SEQUENCE );
$xmldoc = load_ip_xml( $obj_name, $SEQUENCE );
\end{verbatim}

The function 'requirements()' checks whether the sequence object
named 'obj\_name' exists. If not it will terminate the script
with an appropriate error message. If this step is passed, the
function 'load\_ip\_xml()' loads the sequence object from the
workspace. Finally, we fetch the first sequence and print its
first letter:

\begin{verbatim}
$seq_hash = xml2seq( $xmldoc );
$seq_item = $seq_hash->{1};
printf " The first letter of the first sequence is: '%s'\n",
  substr( $seq_item->{$DBA_SEQUENCE}, 0, 1 );
\end{verbatim}

The complete listing of the modified command script 'seq\_letter'
is given below: 

\begin{verbatim}
# seq_letter.pl

use yabby_sys;
use yabby_seq;

use Getopt::Std;

$USAGE = "
 Prints the first letter from the first sequence of a sequence
 object. 

 Usage:
        seq_letter OBJ_NAME

 where OBJ_NAME is the name of an existing sequence object.

 Notes:

 1. This command is merely an example to demonstrate how new
 Yabby commands can be developed.
";

# options
# initialization
@argl = sys_init( @ARGV );
check_call( @argl, [ 1 ] );
$obj_name = $argl[0];

# requirements
requirements( $obj_name, $SEQUENCE );
$xmldoc = load_ip_xml( $obj_name, $SEQUENCE );

# body
$seq_hash = xml2seq( $xmldoc );
$seq_item = $seq_hash->{1};
printf " The first letter of the first sequence is: '%s'\n",
  substr( $seq_item->{$DBA_SEQUENCE}, 0, 1 );
\end{verbatim}

When executed, the command gives the following output:

\begin{verbatim}
yabby> seq_load tom20.fas tom20

 Reading the file 'tom20.fas' ..
 3 sequence(s) found.

yabby> seq_letter tom20

 The first letter of the first sequence is: 'M'
\end{verbatim}

Consider what happens when no arguments are given:

\begin{verbatim}
yabby> seq_letter 

 seq_letter:: ERROR: exactly 1 argument(s) required [ 0 supplied ]
 [ command 'seq_letter' failed ]
\end{verbatim}

This error was raised by the function 'check\_call'. If the sequence
object does not exist:

\begin{verbatim}
yabby> seq_letter ttt

 seq_letter:: missing requirement: 'ttt.seq'

 [ command 'seq_letter' failed ]
\end{verbatim}

The last error was raised by the function 'requirements()'.

\subsection{Extending seq\_letter to work on all sequences}

It would be easy to extend the command seq\_letter to print the
first letter of all sequences from the sequence object. This would
require modifying the body of the command:

\begin{verbatim}
# body
$seq_hash = xml2seq( $xmldoc );
$keys = get_seq_keys( $seq_hash );
printf " '%s' contains %d sequence(s)\n", $obj_name, $#{$keys}+1;

for $key ( @$keys ) {
  $seq_item = $seq_hash->{$key};
  printf " Sequence '%s', the first letter is '%s'\n",
  $seq_item->{$DBA_SEQID}, substr( $seq_item->{$DBA_SEQUENCE}, 0, 1 );
}
\end{verbatim}

The output of 'seq\_letter' is:

\begin{verbatim}
yabby> seq_letter tom20

 'tom20' contains 3 sequence(s)
 Sequence 'A.thaliana2', the first letter: 'M'
 Sequence 'O.sativa', the first letter: 'M'
 Sequence 'L.esculentum', the first letter: 'M'
\end{verbatim}

\subsection{Adding a command switch}

Consider how one could add an optional switch to print the last
letter of each sequence, instead of the first letter.

To add the switch '-t':

\begin{verbatim}
# options
getopts('t');

if ( defined( $opt_t ) ) {
  $opt_t_flag = 1;
} else {
  $opt_t_flag = 0;
}
\end{verbatim}

To extend the command body to take into account possible '-t'
switch: 

\begin{verbatim}
$seq_hash = xml2seq( $xmldoc );
$keys = get_seq_keys( $seq_hash );
printf " '%s' contains %d sequence(s)\n", $obj_name, $#{$keys}+1;

for $key ( @$keys ) {
  $seq_item = $seq_hash->{$key};
  $seq_id = $seq_item->{$DBA_SEQID};
  $sequence = $seq_item->{$DBA_SEQUENCE};

  if ( $opt_t_flag ) {
    $lett = substr( $seq_item->{$DBA_SEQUENCE}, -1, 1 );
  } else {
    $lett = substr( $seq_item->{$DBA_SEQUENCE}, 0, 1 );
  }

  printf " Sequence '%s', the letter is '%s'\n", $seq_id, $lett;
}
\end{verbatim}

The possible use of the modified 'seq\_letter':

\begin{verbatim}
yabby> seq_letter tom20

 'tom20' contains 3 sequence(s)
 Sequence 'A.thaliana2', the letter is 'M'
 Sequence 'O.sativa', the letter is 'M'
 Sequence 'L.esculentum', the letter is 'M'

yabby> seq_letter -t tom20

 'tom20' contains 3 sequence(s)
 Sequence 'A.thaliana2', the letter is 'R'
 Sequence 'O.sativa', the letter is 'R'
 Sequence 'L.esculentum', the letter is 'R'
\end{verbatim}

The full listing of the command 'seq\_letter' is:

\begin{verbatim}
# seq_letter.pl

use yabby_sys;
use yabby_seq;

use Getopt::Std;

$USAGE = "
 Prints the first sequence letter from the sequence object. 

 Usage:
        seq_letter [ options ] OBJ_NAME

 where OBJ_NAME is the name of an existing sequence object.

 Options:

 -t -- print the last letter instead of the first

 Notes:

 1. This command is merely an example to demonstrate how new
 Yabby commands can be developed.
";

# options
getopts('t');

if ( defined( $opt_t ) ) {
  $opt_t_flag = 1;
} else {
  $opt_t_flag = 0;
}

# initialization
@argl = sys_init( @ARGV );
check_call( @argl, [ 1 ] );
$obj_name = $argl[0];

# requirements
requirements( $obj_name, $SEQUENCE );
$xmldoc = load_ip_xml( $obj_name, $SEQUENCE );

# body
$seq_hash = xml2seq( $xmldoc );
$keys = get_seq_keys( $seq_hash );

printf " '%s' contains %d sequence(s)\n", $obj_name, $#{$keys}+1;

for $key ( @$keys ) {

  $seq_item = $seq_hash->{$key};
  $seq_id = $seq_item->{$DBA_SEQID};
  $sequence = $seq_item->{$DBA_SEQUENCE};

  if ( $opt_t_flag ) {
    $lett = substr( $seq_item->{$DBA_SEQUENCE}, -1, 1 );
  } else {
    $lett = substr( $seq_item->{$DBA_SEQUENCE}, 0, 1 );
  }

  printf " Sequence '%s', the letter is '%s'\n", $seq_id, $lett;
}
\end{verbatim}

\subsection{A command that creates an object}

The command 'seq\_letter' is very simple in that it merely prints
something on the output screen; it does not modify an existing
object nor it creates any new Yabby objects. Consider a command
that actually creates a sequence object. An example for this may
be a command that chops the first letter from each sequence in
the sequence object, and saves the result as a new sequence object.
This requires two names to be given on the input, the name of
an existing sequence object, and the name of the sequence object
that will be created:

\begin{verbatim}
seq_letterc OBJ_NAME OBJ_NAME_NEW
\end{verbatim}

where we named the new command 'seq\_letterc' to distinguish from
the previous 'seq\_letter'.

To build the command 'seq\_letterc' we create the file 'seq\_letterc.pl'
in the Yabby library:

\begin{verbatim}
# seq_letters.pl

use yabby_sys;
use yabby_seq;

use Getopt::Std;

$USAGE = "
 Chops the first sequence letter from the sequence object, and
 saves the result as a new sequence object.

 Usage:
        seq_letters OBJ_NAME OBJ_NAME_NEW

 where OBJ_NAME is the name of an existing sequence object.

 Notes:

 1. This command is merely an example to demonstrate how new
 Yabby commands can be developed.
";
\end{verbatim}

Two arguments are now required:

\begin{verbatim}
# options
# initialization
@argl = sys_init( @ARGV );
check_call( @argl, [ 2 ] );
$obj_name = $argl[0];
$obj_name2 = $argl[1];
\end{verbatim}

We can use the same construct to check for requirements and fetch the
sequence object:

\begin{verbatim}
# requirements
requirements( $obj_name, $SEQUENCE );
$xmldoc = load_ip_xml( $obj_name, $SEQUENCE );

# body
$seq_hash = xml2seq( $xmldoc );
$keys = get_seq_keys( $seq_hash );

printf " '%s' contains %d sequence(s)\n", $obj_name, $#{$keys}+1;
\end{verbatim}

The new command requires a new sequence object to be created, and
populated with sequences from the existing sequence object (minus
the first letter). We first initialize a new sequence object:

\begin{verbatim}
$seq_hash2 = {};
\end{verbatim}

The same construct as in 'seq\_letter' could be used to loop through
the sequences. Now, we also create a new sequence for each existing
sequence, chop the first letter, and joing the result to the new
sequence object:

\begin{verbatim}
for $key ( @$keys ) {

  $seq_item = $seq_hash->{$key};

  $seq_item_new = {};
  $seq_item_new->{$DBA_SEQID} = $seq_item->{$DBA_SEQID};
  $seq_item_new->{$DBA_COMMENT} = $seq_item->{$DBA_COMMENT};
  $seq_item_new->{$DBA_SEQUENCE} = $seq_item->{$DBA_SEQUENCE};

  # chop the first letter from the sequence
  substr( $seq_item_new->{$DBA_SEQUENCE}, 0, 1 ) = "";

  $seq_hash2->{$key} = $seq_item_new;
}
\end{verbatim}

We need to save the newly created sequence hash 'seq\_hash2' as the
new sequence object. In the first step, we convert the sequence hash
object into an XML document:

\begin{verbatim}
$xmldoc = seq2xml( $seq_hash2 );
\end{verbatim}

This is the reverse of the above command 'xml2seq()', which converts
an XML document representing a sequence object into a sequence hash,
the form all commands employ to represent the sequence object in
memory.  The functions'xml2seq()' and 'seq2xml()' are specific for
sequence objects, and are defined in the package 'yabby\_seq.pm'.
Finally, we store the XML sequence object in the workspace:

\begin{verbatim}
printf " Saving chopped sequences as '%s'\n", $obj_name2;
save_ip_xml( $xmldoc, $obj_name2, $SEQUENCE, $WARN_OVERW );
\end{verbatim}

The function 'save\_ip\_xml()' sends the XML representation of an
object to the workspace. This function is the reverse analog of
the previously used function 'load\_ip\_xml()', which fetches the
XML representation of an object from the workspace. These two
functions are defined in the package 'yabby\_sys.pm'.

The arguments to the function 'save\_ip\_xml()' are are follows:
the XML representation of an object ('xmldoc'), the name of the
object to be created ('obj\_name2'), the type of the object to be
created ('SEQUENCE' in this case), and the flag which determines
whether the warning will be issued is the object with the same
name and the same type already exists in the workspace and will
be overwritten ('WARN\_OVERW').

The command 'seq\_letterc' could be used as follows:

\begin{verbatim}
yabby> seq_load tom20.fas tom20

 Reading the file 'tom20.fas' ..
 3 sequence(s) found.

yabby> what      

    object(s)      type
  ------------------------------
    tom20          seq           

yabby> seq_letterc tom20 tom20_chop

 'tom20' contains 3 sequence(s)
 Saving chopped sequences as 'tom20_chop'

yabby> what

    object(s)      type
  ------------------------------
    tom20          seq           
    tom20_chop     seq           

yabby> print tom20.seq

>A.thaliana2 [ A.thaliana2 ]
MEFSTADFERFIMFEHARKNSEAQYKNDPLDSENLLKWGGALLELSQFQPIPEAKLMLND
AISKLEEALTINPGKHQALWCIANAYTAHAFYVHDPEEAKEHFDKATEYFQRAENEDPGN
DTYRKSLDSSLKAPELHMQFMNQGMGQQILGGGGGGGGGGMASSNVSQSSKKKKRNTEFT
YDVCGWIILACGIVAWVGMAKSLGPPPPAR
>O.sativa [ O.sativa ]
MDMGAMSDPERMFFFDLACQNAKVTYEQNPHDADNLARWGGALLELSQMRNGPESLKCLE
DAESKLEEALKIDPMKADALWCLGNAQTSHGFFTSDTVKANEFFEKATQCFQKAVDVEPA
NDLYRKSLDLSSKAPELHMEIHRQMASQASQAASSTSNTRQSRKKKKDSDFWYDVFGWVV
LGVGMVVWVGLAKSNAPPQAPR
>L.esculentum [ L.esculentum ]
MDMQSDFDRLLFFEHARKTAETTYATDPLDAENLTRWAGALLELSQFQSVSESKKMISDA
ISKLEEALEVNPQKHDAIWCLGNAYTSHGFLNPDEDEAKIFFDKAAQCFQQAVDADPENE
LYQKSFEVSSKTSELHAQIHKQGPLQQAMGPGPSTTTSSTKGAKKKSSDLKYDVFGWVIL
AVGLVAWIGFAKSNMPXPAHPLPR

yabby> print tom20_chop.seq

>A.thaliana2 [ A.thaliana2 ]
EFSTADFERFIMFEHARKNSEAQYKNDPLDSENLLKWGGALLELSQFQPIPEAKLMLNDA
ISKLEEALTINPGKHQALWCIANAYTAHAFYVHDPEEAKEHFDKATEYFQRAENEDPGND
TYRKSLDSSLKAPELHMQFMNQGMGQQILGGGGGGGGGGMASSNVSQSSKKKKRNTEFTY
DVCGWIILACGIVAWVGMAKSLGPPPPAR
>O.sativa [ O.sativa ]
DMGAMSDPERMFFFDLACQNAKVTYEQNPHDADNLARWGGALLELSQMRNGPESLKCLED
AESKLEEALKIDPMKADALWCLGNAQTSHGFFTSDTVKANEFFEKATQCFQKAVDVEPAN
DLYRKSLDLSSKAPELHMEIHRQMASQASQAASSTSNTRQSRKKKKDSDFWYDVFGWVVL
GVGMVVWVGLAKSNAPPQAPR
>L.esculentum [ L.esculentum ]
DMQSDFDRLLFFEHARKTAETTYATDPLDAENLTRWAGALLELSQFQSVSESKKMISDAI
SKLEEALEVNPQKHDAIWCLGNAYTSHGFLNPDEDEAKIFFDKAAQCFQQAVDADPENEL
YQKSFEVSSKTSELHAQIHKQGPLQQAMGPGPSTTTSSTKGAKKKSSDLKYDVFGWVILA
VGLVAWIGFAKSNMPXPAHPLPR
\end{verbatim}

Since no safeguards were put against overwriting an existing
sequence object, the command 'seq\_letterc' could be used to
chop sequences from the N-terminus in place,

\begin{verbatim}
yabby> seq_letterc tom20 tom20

 'tom20' contains 3 sequence(s)
 Saving chopped sequences as 'tom20'
 [ seq_letterc: 'tom20.seq' exists, overwritten ]

yabby> seq_letterc tom20 tom20

 'tom20' contains 3 sequence(s)
 Saving chopped sequences as 'tom20'
 [ seq_letterc: 'tom20.seq' exists, overwritten ]
\end{verbatim}

\subsection{Creating a new object type}

Yabby supports two internal representations of data in the workspace:
simple lists and XML objects. To create a new object type one must
first decide whether the data in question can be effectively
represented with a two-dimensional table. Two-dimensional tables
can be effectively represented with two-dimensional lists, where
each item in the list corresponds to the table row. Lists are simple
and efficient in Perl, and if suitable this is the preferred
representation of data. However, XML format is much more powerful
and flexible, and is the preferred solution when the data has
a complex inhernal structure.

A sequence object is an example for objects which use XML to store 
data into the workspace. A Yabby commands store sequence objects
in memory in the form of a hash (sequence hash).  All sequence
commands the standard function 'load\_ip\_xml()' to fetch the XML
representation of a sequence object from the workspace. Subsequently
the object is converted into a more efficient structure, a
sequence hash, with the function 'xml2seq()'. After the sequences
are manipulated, or a new sequence object is created, they result
may be stored in the workspace. If this is required, the reverse
transformation process takes place.  The sequence hash is convereted
into an XML object with the function 'seq2xml()', and the resulting
XML object is saved in the workspace with the function 'save\_ip\_xml()'.

The functions 'load\_ip\_xml()' and 'save\_ip\_xml()' can be used
to load/store the XML representation of any object in the workspace.
The analogous functions for objects represented as a two-dimensional
lists are 'load\_ip()' and 'save\_ip()'.

As an example we will create a new object type named "seqid" to
represent the list of sequence IDs. To demonstrate use of this
object we will also create the command 'seq2id' which creates the
"seqid" object from an existing sequence object.

The first step is to create the script 'seq2id.pl' in the Yabby
library, and we start as previously:

\begin{verbatim}
# seq2id.pl

use yabby_sys;
use yabby_seq;

use Getopt::Std;

$USAGE = "
 Converts a sequence object into seqid object.

 Usage:
        seq2id OBJ_NAME

 where OBJ_NAME is the name of an existing sequence object.

 Notes:

 1. This command is merely an example to demonstrate how a
 new object type can be implemented.
";

# options
# initialization
@argl = sys_init( @ARGV );
check_call( @argl, [ 1 ] );
$obj_name = $argl[0];

# requirements
requirements( $obj_name, $SEQUENCE );
$xmldoc = load_ip_xml( $obj_name, $SEQUENCE );

# body
$seq_hash = xml2seq( $xmldoc );
$keys = get_seq_keys( $seq_hash );
\end{verbatim}

With this we have the sequence hash in memory. In 'yabby\_seq.pm' we
add the name of the "seqid" object:

\begin{verbatim}
$SEQUENCE = "seq";
$MOTIF = "motif";
$SEQID = "seqid";
\end{verbatim}

The new object will be represented as a one-dimensional list, where
each sequence ID string will be one element of this list. This is
equivalent to a two-dimensional table, where there is only one
column in the table. Next we create the variable 'seqid\_obj' to
hold the 'seqid' object, fill this object with the values from
the sequence hash, and store the object in the workspace by using
the standard function:

\begin{verbatim}
$seqid_obj = [];

for $key ( @$keys ) {

  $seq_item = $seq_hash->{$key};
  $seq_id = $seq_item->{$DBA_SEQID};

  push @$seqid_obj, [ $seq_id ];
}

print " Saving '$obj_name.$SEQID'\n";
save_ip( $seqid_obj, $obj_name, $SEQID, $WARN_OVERW );
\end{verbatim}

On a technical note, all objects that are represents with two dimensional
tables are initialized as annonymous arrays:

\begin{verbatim}
$seqid_obj = [];
\end{verbatim}

When filled with values, each element of this array is a reference
to anonymous array. In this case containing only one element 'seq\_id':

\begin{verbatim}
push @$seqid_obj, [ $seq_id ];
\end{verbatim}

This format is very flexible.  If the data table needs to contain more
than one element per row, these would be simply added to the anonymous
reference representing a table row:

\begin{verbatim}
push @$seqid_obj, [ $seq_id, $colum2_elem, $colum3_elem, ... ];
\end{verbatim}

Consider how the object 'mol', which is represented with a two-dimensional
table is build (example in 'yabby\_mol.pm'):

\begin{verbatim}
push @$mol, [ $resi_num, $resi_name, $atom_name, $segmentID ];
\end{verbatim}

The function save\_ip() expects the reference to an anonymous array,
where each element to this array is a reference to anonymous array.
The latter may contain one or more elements.

The complete listing for the command script 'seq2id' is:

\begin{verbatim}
# seq2id.pl

use yabby_sys;
use yabby_seq;

use Getopt::Std;

$USAGE = "
 Converts a sequence object into seqid object.

 Usage:
        seq2id OBJ_NAME

 where OBJ_NAME is the name of an existing sequence object.

 Notes:

 1. This command is merely an example to demonstrate how a
 new object type can be implemented.
";

# options
# initialization
@argl = sys_init( @ARGV );
check_call( @argl, [ 1 ] );
$obj_name = $argl[0];

# requirements
requirements( $obj_name, $SEQUENCE );
$xmldoc = load_ip_xml( $obj_name, $SEQUENCE );

# body
$seq_hash = xml2seq( $xmldoc );
$keys = get_seq_keys( $seq_hash );

printf " '%s' contains %d sequence(s)\n", $obj_name, $#{$keys}+1;

$seqid_obj = [];

for $key ( @$keys ) {

  $seq_item = $seq_hash->{$key};
  $seq_id = $seq_item->{$DBA_SEQID};

  push @$seqid_obj, [ $seq_id ];
}

print " Saving '$obj_name.$SEQID'\n";
save_ip( $seqid_obj, $obj_name, $SEQID, $WARN_OVERW );
\end{verbatim}

And below is the output when the command is executed on an example
sequence object:

\begin{verbatim}
yabby> seq_load tom20.fas tom20

 Reading the file 'tom20.fas' ..
 3 sequence(s) found.

yabby> seq2id tom20

 'tom20' contains 3 sequence(s)
 Saving 'tom20.seqid'

yabby> what

    object(s)      type
  ------------------------------
    tom20          seq           
                   seqid         
\end{verbatim}

Of course, at this point nothing can be done with the 'seqid' object.
It cannot be even printed on the screen:

\begin{verbatim}
yabby> print tom20.seqid

 print:: ERROR: printing the property 'seqid' not yet implemented
 [ command 'print' failed ]
\end{verbatim}

This is because the printing of each particular object type has to
be enabled in the 'print' command. However, one can view the 'seqid'
object directly from the filesystem:

\begin{verbatim}
yabby> cat .yabby/tom20.seqid
A.thaliana2
O.sativa
L.esculentum
\end{verbatim}

Since 'tom20.seqid' is just a simple text file, containing sequence
IDs listed one per row.


